---
title: "Biclique Tests"
author: "Jacob McGill"
date: "2024-10-28"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, include = FALSE}
library(tidyverse)
library(fields)
library(ggraph)
library(tidygraph)
library(igraph)
library(Matrix)
library(purrr)
library(patchwork)
library(ivreg)
library(rdist)
```

## Biclique Method

I'm now going to switch to applying the clique based randomization test developed in the paper *A Graph-Theoretic Approach to Randomization Tests of Causal Effects Under General Interference* (Puelz, Basse, Feller, and Toulis, 2021). This section will apply this method (referred to as biclique method for short). This method does not use linear regressions to estimate peer effects. Instead, it is a variation of randomization test. A randomization test calculates the probability of the observed outcome occurring if the treatment had no effect on the outcome. However, a simple randomization test breaks down when peer effects, as it assumes that there is no spillover, the treated status of a subject affecting an untreated peer. To test for the existence of peer effects, you can conduct a conditional randomization test on a subset of the data. Conditional randomization takes a subset of the data where you can conduct a randomization test for peer effects. However, this brings up a new problem: constructing the subset of the data to conduct the randomization test. The biclique method is generalizable method that constructs the subsets that can be used to test for peer effects in a relatively efficient manner. The package used in document to test for peer effects is  BicliqueRT. Github documentation can be found [here](https://github.com/dpuelz/BicliqueRT).

## Biclique Application
tes
I will take the social network generated by soc_net_writeup.Rmd for testing the biclique. We wan extract the peer columns from the node dataframe to create a function that simulates peer effects. The treatment vector can also be extracted from the node dataframe.

```{r, include = FALSE}
library(BicliqueRT)
# The design function
design_fn = function(){rbinom(289, 1, 0.05)} 

# The exposure function
exposure_i = function(z, i){
  stopifnot(length(z)==N)
  z[i]
}
#Will need to adjust this exposure function: exposure function outlines peer effects
# The null
null_equiv = function(e1, e2){
  identical(e1, e2)
}
```
```{r, include = FALSE}
frame = tbl_graph %>%
  activate(nodes) %>%
  as_tibble()
treatment = frame$treated
first_peer = frame$first_order
second_peer = frame$second_order
third_peer = frame$third_order
```
```{r, include = FALSE}
N = 289
Y_test = 0.1 + 5*treatment  + 7*first_peer  + rnorm(N)
Z_test = rbinom(N, 1, 0.05)
```
```{r, include = FALSE}
#My test. To fix this, I need to get the adjacency matrix of our treatment.
H0_test = list(design_fn=design_fn, exposure_i=exposure_i, null_equiv=null_equiv)
bd_test = biclique.decompose(Z_test, H0_test, controls= list(method="greedy", mina=3, num_randomizations = 4e3))
```
```{r, echo = FALSE}
Tstat_test = gen_tstat(adjacency_matrix, "elc")
testout_test = clique_test(Y_test,Z_test, Tstat_test, bd_test)
testout_test$p.value # p-value of the test
```
Notes for David: As you can see above, we're getting a p-value of 3. We're also getting the above warning about the test statistic or its randomization
```{r}
Tstat_test
```
```{r}
testout_test
```
```{r}
testout_test$p.value
```
Now lets expand to peer effects from 2nd and 3rd degree peers.
```{r, include = FALSE}
N = 289
Y_peer = 0.1 + 5*treatment  + 7*first_peer + 1.5*second_peer + 0.5*third_peer + rnorm(N)
Z_peer = rbinom(N, 1, 0.05)
```
```{r, include = FALSE}
#My test. To fix this, I need to get the adjacency matrix of our treatment.
H0_peer = list(design_fn=design_fn, exposure_i=exposure_i, null_equiv=null_equiv)
bd_peer = biclique.decompose(Z_peer, H0_peer, controls= list(method="greedy", mina=3, num_randomizations = 4e3))
```
```{r, echo = FALSE}
Tstat_peer = gen_tstat(adjacency_matrix, "elc")
testout_peer = clique_test(Y_peer,Z_peer, Tstat_peer, bd_peer)
testout_peer$p.value # p-value of the test
```
```{r, include = FALSE}
# The design function
design_fn = function(){rbinom(289, 1, 0.5)} 

# The exposure function
exposure_i = function(z, i){
  stopifnot(length(z)==N)
  z[i]
}
#Will need to adjust this exposure function: exposure function outlines peer effects
# The null
null_equiv = function(e1, e2){
  identical(e1, e2)
}
```
 

