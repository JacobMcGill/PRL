---
title: "Regression vs. Biclique"
author: "Jacob McGill"
date: "2024-11-15"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, include = FALSE}
library(tidyverse)
library(fields)
library(ggraph)
library(tidygraph)
library(igraph)
library(Matrix)
library(purrr)
library(patchwork)
library(ivreg)
library(rdist)
```

## Background

Previously, I have discussed various strategies to identify peer effects using linear regressions and potential flaws in those strategies, as discussed in *The Perils of Peer Effects* (Angrist, 2014). I also showed how peer effects can be simulated using social networks (such as those generated by the tidygraph package) and assessed the effectiveness of linear regressions in identifying peer effects. Finally, I moved onto the biclique method outlined in *A Graph-Theoretic Approach to Randomization Tests of Causal Effects Under General Interference* (Puelz, Basse, Feller, and Toulis, 2021) and showed how it could be used to identify peer effects in social networks as well. 

I want to focus this section on comparing linear regression to the biclique method, specifically their effectiveness and when is better than the other.

## Assessment

Steps:
1.Generate a social network

```{r, include = FALSE}
set.seed(11182024)
plane <- c(1000, 1000)

poisson_para <- .3 * 10^(-3)
beta <- .45 * 10^3
gamma <- .52

n_nodes <- rpois(1, poisson_para * plane[1] * plane[2])

weights <- runif(n_nodes)

x = plane[1] * runif(n_nodes)
y = plane[2] * runif(n_nodes)

phi <- function(z) {
  pmin(z^(-1.8), 1)
} 

dist_matrix <-rdist(tibble(x,y))

weight_matrix <- outer(weights, weights, FUN="*") 
con_matrix_prob <- phi(1/beta * weight_matrix^gamma*dist_matrix^2)

con_matrix <- Matrix(rbernoulli(1,con_matrix_prob), sparse=TRUE)
con_matrix <- con_matrix * upper.tri(con_matrix) 
adjacency_matrix <- con_matrix + t(con_matrix)
graph <- graph_from_adjacency_matrix(adjacency_matrix, mode="undirected")

tbl_graph <- as_tbl_graph(graph)

hub_id <- which.max(degree(graph))

tbl_graph <- tbl_graph %>%
  activate(nodes) %>%
  mutate(
    x = x,
    y = y,
    hub_dist = replace_na(bfs_dist(root = hub_id), Inf),
    degree = degree(graph),
    friends_of_friends = replace_na(local_ave_degree(), 0),
    cluster = as.factor(group_infomap())
  )

sim_graph = tbl_graph
```
```{r, include = FALSE}
tbl_graph = tbl_graph %>%
  activate(nodes) %>%
  mutate(treated = rbinom(n(), 1, 0.05),
         treated_status = as.factor(treated),
         shape_type = as_factor(ifelse(treated == 1, 2, 1)))

tbl_graph = tbl_graph %>%
  activate(nodes) %>%
  mutate(Male = as.factor(rbinom(n(), 1, 0.5)),
         educ = rnorm(n(), 13, 2.5))
treated
```
```{r, include = FALSE}

tbl_graph = tbl_graph %>%
  activate(nodes) %>%
  mutate(neighborhood_1 = local_members(order = 1),
         neighborhood_2 = local_members(order = 2),
         neighborhood_3 = local_members(order = 3)) 



Treated_neighbors_first = function(tidy_graph) {
  neighbor_treat = c()
  node = tidy_graph %>%
    activate(nodes) %>%
    as_tibble()
  node_rows = nrow(node)
  for (i in 1:node_rows){
    treated_count = 0
    extract = node$neighborhood_1[i]
    extracted_vector = extract[[1]]
    for (j in extracted_vector){
      if(node$treated[j] == 1) {
        treated_count = treated_count + 1
      }
    }
    neighbor_treat[i] = treated_count
  }
  tidy_graph = tidy_graph %>%
    activate(nodes) %>%
    mutate(first_order= neighbor_treat - treated)
  return(tidy_graph)
}

Treated_neighbors_second = function(tidy_graph) {
  neighbor_treat = c()
  node = tidy_graph %>%
    activate(nodes) %>%
    as_tibble()
  node_rows = nrow(node)
  for (i in 1:node_rows){
    treated_count = 0
    extract = node$neighborhood_2[i]
    extracted_vector = extract[[1]]
    for (j in extracted_vector){
      if(node$treated[j] == 1) {
        treated_count = treated_count + 1
      }
    }
    neighbor_treat[i] = treated_count
  }
  tidy_graph = tidy_graph %>%
    activate(nodes) %>%
    mutate(second_order= neighbor_treat - treated - first_order)
  return(tidy_graph)
}


Treated_neighbors_third = function(tidy_graph) {
  neighbor_treat = c()
  node = tidy_graph %>%
    activate(nodes) %>%
    as_tibble()
  node_rows = nrow(node)
  for (i in 1:node_rows){
    treated_count = 0
    extract = node$neighborhood_3[i]
    extracted_vector = extract[[1]]
    for (j in extracted_vector){
      if(node$treated[j] == 1) {
        treated_count = treated_count + 1
      }
    }
    neighbor_treat[i] = treated_count
  }
  tidy_graph = tidy_graph %>%
    activate(nodes) %>%
    mutate(third_order= neighbor_treat - treated - first_order - second_order)
  return(tidy_graph)
}


Treated_neighbors_Total = function(tidy_graph) {
  neighbor_treat = c()
  node = tidy_graph %>%
    activate(nodes) %>%
    as_tibble()
  node_rows = nrow(node)
  for (i in 1:node_rows){
    treated_count = 0
    extract = node$neighborhood_3[i]
    extracted_vector = extract[[1]]
    for (j in extracted_vector){
      if(node$treated[j] == 1) {
        treated_count = treated_count + 1
      }
    }
    neighbor_treat[i] = treated_count
  }
  tidy_graph = tidy_graph %>%
    activate(nodes) %>%
    mutate(total= neighbor_treat - treated)
  return(tidy_graph)
}

Treated_neighbors = function(tidy_graph) {
  first_order = Treated_neighbors_first(tidy_graph)
  second_order = Treated_neighbors_second(first_order)
  third_order = Treated_neighbors_third(second_order)
  final = Treated_neighbors_Total(third_order)
  return(final)
}
```
```{r, include = FALSE}
tbl_graph = Treated_neighbors(tbl_graph)
node_data = tbl_graph %>%
  activate(nodes) %>%
  as_tibble()
```

2. Create a data generating process where outcomes depend on both treatment status and the treatment status of peers
  a. Need to be clear about how peer effects work in this context; may be important for assessing effectiveness
  
First, we will start with data generating process where having at least one treated peer changes your outcome if you are not treated. In this data generating process, having treated peers does not "stack", so the effect of 2 treated peers is the same as one treated peer.
```{r, include = FALSE}
#First, we will generate these peer effects in the nodes dataframe of the tidygraph object
node_frame = tbl_graph %>%
    activate(nodes) %>%
    as_tibble()
nodes_numbers = nrow(node_frame)
tbl_graph = tbl_graph %>%
  activate(nodes) %>%
  mutate(peer_first = ifelse(first_order >= 1 & treated == 0, 1, 0),
         outcome_no_peer = ifelse(treated == 1, rnorm(nodes_numbers, 10, 0.5), rnorm(nodes_numbers, 5, 0.5)),
         outcome_peer = ifelse(treated == 1, rnorm(nodes_numbers, 10, 0.5), 
                               ifelse(first_order >= 1, rnorm(nodes_numbers, 7.5, 0.5), 
                                      rnorm(nodes_numbers, 5, 0.5))))
dgp_test = tbl_graph %>%
  activate(nodes) %>%
  as_tibble()
# Next, we will generate it in vector form, which will allow us to apply the biclique method
```
```{r, include = FALSE}
no_peer = summary(lm(outcome_no_peer ~ treated + first_order, dgp_test))
peer_first = summary(lm(outcome_peer ~ treated + first_order, dgp_test))
peer_thresh = summary(lm(outcome_peer ~ treated + peer_first, dgp_test))
```
3. Run a one off test of each method, assessing its effectiveness
4. Test how well each work with common issues with identifying peer effects, as discussed in Angrist
  a: omitted variable bias (may be hard since this an RCT), group shocks, noise
5. Run more "expansive" tests; for example, run the data a million times and test the effectiveness of each method.
6. Conclusion, tie together with wellness project